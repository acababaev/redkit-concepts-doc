# Ожидаемый эффект

При работе в IDE QtCreator, по нажатию клавиши F1 происходит анализ текущего слова, на котором стоит курсор. В рамках анализа необходимо искать в слове заданные пользователем строки. Для каждой такой строки есть небольшое текстовое описание и ссылка на статью из базы знаний проекта (для примера и тестирования возьмем https://www.jetbrains.com/ru-ru/youtrack/). Если в слове встретилось несколько таких строк, то в одном окне выводится несколько форм подряд, в том порядке, в котором слова встретились.

# Зачем это вообще?

В больших проектах много различных имен сущностей, причем как со стороны предметной области, так и со стороны архитектурного смысла внутри программы, который мы вкладываем. Например **IEC104ServerBindingTreeModel**: здесь можно выделить сущности 
- IEC104 (протокол передачи данных)
- ServerBinding (Привязки к серверу)
- TreeModel (древовидная модель)

### Демо-пример
Возьмем ранее упомянутый **IEC104ServerBindingTreeModel**. Неважно в какой части программы мы находимся - такая документация работает сквозь весь проект. Допустим мы встретили такого монстра в коде, жмякаем на него F1 и получаем следующее (это не рабочий вариант, а лишь демонстрация, как это примерно бы работало:
![test](https://user-images.githubusercontent.com/71624171/205927342-4e4536ae-43b7-4e7b-8a95-d20031bdf87d.gif)

### Эффект от внедрения
- повышается общее понимание проекта для всех членов команды, за счет того что все говорят на одном языке и используют в коммуникациях между собой документированные термины
- новые сотрудникам быстрее вливаются в понимание происходящего, могут получить ответы на некоторые вопросы, не отвлекая коллег. А вопросы по терминам у новичков абсолютно всегда возникают
- повысит информативность кода. Своего рода это дополнительная мета-документация, которая может дать ответы на вопросы в абсолютно разных частях проекта, главное чтобы использовались одни и те же термины, когда мы делаем концептуально одно и то же 
- В программулине будет фича накидать слов для документации, которую программисты пишут в коде. Для примера IEC104ServerBindingTreeModel, будет сгенерировано что-то вроде "Древовидная модель Привязка Сервер Протокол IEC-104". А программист лишь отредактирует в человеческом формате и не будет ломать голову над документацией

# Как с этим работать пользователю

Пользователю должно быть удобно создавать новые слова и соответственно описание к ним. Также должен быть файл настроек с именем ".redkit-concepts-doc". Этот файл с настройками будет располагаться в корне репозитория проекта пользователя. Программа должна найти этот файл, рекурсивно поднимаясь вверх по директориям, начиная от директории, в которой лежит файл (с которым работал пользователь, когда нажал F1). В файле настроек пользователь будет заносить информацию о директориях, в которых искать инфу о том, какие слова и словосочетания будут в анализируемом списке.

# В будущем возможно добавиться, сейчас нет

Конфигурационные файлы .redkit-concepts-doc могут лежать и в промежуточных директориях, например в конкретной папке с исходниками, или в папке библиотеки. Причем этот файл будет содержать какие-то свои настройки и будет промаркирован, что он промежуточный, чтобы програмулина искала дальше корневой файл. Среди настроек этого промежуточного файла настроек может быть указание показать пользователю дополнительную какую-то документацию, которая имеет отношение к текущие директории. И програмулина, при открытии, будет содержать опцию, что здесь есть еще дополнительная документация.

# [Техническая часть] 

# Как получить слово из файла

В QtCreator есть раздел настроек ExternalTools. Наша програмулина будет лежать там, это позволит использовать внутренний контекст IDE. В рамках нашей задачи, на вход програмулине будет поступать 3 аргумента - путь до файла, номер строки, номер колонки. Все эти 3 аргумента можно выцепить, используя следующую картинку
![image](https://user-images.githubusercontent.com/71624171/205485019-0601ce21-072d-480d-b483-6f15ced174ff.png)

Поле Arguments это как раз аргументы, которые пойдут на вход програмулине.
Соответственно внутри програмулины необходимо найти нужный файл, нужную строку и колонку и получить слово, двигаясь влево и вправо от заданной колонки, в поисках символов, которыми нельзя называть переменные и классы (пробелы, знаки препинания и тд). Например, рассмотрим ситуацию
![image](https://user-images.githubusercontent.com/71624171/205485315-669acae1-9ce0-4668-b692-904636d878cf.png)

Видно что курсор стоит на 16 строке и 16 колонке. Ожидаем, что программа сможет вычленить отсюда "ClangFormatExecutor". Двигаясь влево от курсора, мы уткнемся в пробел, а двигаясь вправо от курсора мы уткнемся в ';', Вот у нас и получилось слово

